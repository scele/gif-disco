/**
 * This file provided by Facebook is for non-commercial testing and evaluation
 * purposes only. Facebook reserves all rights not expressly granted.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import ResizableAndMovable from 'react-resizable-and-movable';

class Dancer extends Component {
  constructor(props) {
    super(props);
    this.state = { x: 20, y: 20, height: 200, width: 100 };
  }
  resize(direction, styleSize, clientSize, delta) {
      //this.setState({ width: styleSize.height, height: styleSize.height });
  }
  render() {
    return (
      <ResizableAndMovable
        x={this.state.x}
        y={this.state.y}
        height={this.state.height}
        width={this.state.width}
        onResize={this.resize.bind(this)}
        canUpdateSizeByParent={true}
        minWidth={100}
        minHeight={100}
        isResizable={{ top:true, right:false, bottom:true, left:false, topRight:false, bottomRight:false, bottomLeft:false, topLeft:false }}
        bounds={'parent'}
        className="dancer"
      >
        <img src={this.props.src} />
     </ResizableAndMovable>
    );
  }
}

var Scene = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: 'json',
      cache: false,
      success: function(data) {
        this.setState({backgrounds: data.backgrounds, gifs: data.gifs});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  handleCommentSubmit: function(comment) {
    var comments = this.state.data;
    // Optimistically set an id on the new comment. It will be replaced by an
    // id generated by the server. In a production application you would likely
    // not use Date.now() for this and would have a more robust system in place.
    comment.id = Date.now();
    var newComments = comments.concat([comment]);
    this.setState({data: newComments});
    $.ajax({
      url: this.props.url,
      dataType: 'json',
      type: 'POST',
      data: comment,
      success: function(data) {
        this.setState({backgrounds: data.backgrounds, gifs: data.gifs});
      }.bind(this),
      error: function(xhr, status, err) {
        this.setState({data: comments});
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  getInitialState: function() {
    return {backgrounds: [], gifs: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    var bg = this.state.backgrounds[0];
    if (!bg)
      return null;

    var gifs = this.state.gifs;
    var dancers = bg.gifs.map(function(place, i) {
      return (
        <Dancer key={i} src={gifs[i]} />
      );
    });

    return (
      <div className="scene">
        {dancers}
        <img className="bg" src={bg.url} />
      </div>
    );
  }
});

ReactDOM.render(
  <Scene url="/backgrounds" pollInterval={2000} />,
  document.querySelector('#content')
);